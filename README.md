# Huffman_archiver
Huffman archiver.
-   Режим архивирования файла.

На вход подается файл, программа открывает его в бинарном режиме чтения.
Создается словарь, в котором ключом являются байты, а значением частоты
этих байт. Этот словарь преобразуется в массив кортежей (байт, частота)
и сортируется по частоте. Так как это аналог цифровой сортировки, в
среднем время работы составляет O(n), где n -- длина словаря. Далее из
каждого кортежа создается элемент класса MYNODE, отличительная черта
которого -- возможность указания ссылки на левый и правый дочерний
элемент. Следующим шагом является построение дерева Хаффмана за линейное
время и последующий его обход. Результат обхода хранится в словаре.
После этого программа снова читает файл в бинарном режиме и кодирует
информацию согласно словарю, записывая каждые 8 подряд идущих символов в
виде байта.

Структура файла .zmh. Сначала записывается массив ключей словаря
кодирования. Далее записываются значения для этих ключей в том же
порядке. Приписывается длина последнего байта и добавляется сам
закодированный файл.

-   Режим разархивирования файла.

Алгоритм достаточно прост: восстанавливается словарь данных и заменяется
на исходные байты в закодированной части файла.

-   Оценка.

К сожалению, на больших файлах (\> 20Мб) алгоритм полностью проигрывает
всем известным архиваторам (7z, zip, rar). Некоторые файлы в формате
.pdf после архивации стали только больше. Файлы в формате .jpg после
архивации практически не изменили свой размер. Лучше всего программа
показала себя на файлах в формате .txt. Время работы алгоритма в разы
больше, чем у классических архиваторов. Самое трудоемкое действие по
времени в режиме сжатия -- это кодирование файла с помощью словаря.

![](vertopal_ecc78ef4e08742bfb8ef40530cd91c72/media/image1.png){width="7.539583333333334in"
height="2.140972222222222in"}Ниже представлена таблица с оценкой
некоторых файлов в различных форматах.
![image1](https://user-images.githubusercontent.com/26380064/173094114-5b31c8e8-bdc4-4971-a0ea-5c8ee878efdf.png)
